[{"content":"2022总结 今天是邻近2022年除夕的倒数第二天，回到家后好像也没什么事情干，索性写下了这边博客，算上为自己的2022年画上一个句号。 回顾起我的2022，应该还算的上顺风顺水。。。为什么呢，且听我细细道来。\n论文发表 由于鄙人是一名双非的研二学生，在经历了自己的一番努力后，我的小论文也是在2022的8月份迎来了得到了CCBR的认可!\n在这里确实要感谢我的导师，虽然只是一篇普通的EI会议，但是老师前前后后给我修改了很多遍，而且是一个单词一个单词的给我耐心修改，所以这里真的很感谢我的导师,如果没有导师的耐心修改，可能就不会有这篇论文的成功。 这是我的小狗\r实习经历 在小论文发表后，我便踏上了找实习的道路，这一路确实也是历经坎坷，有发offer但跟我技术不匹配的；也有毁offer的，索性最后的结果是好的，我在11月中旬找到一份云计算的公司,于是便开始了我的实习之路。\n11-12月 初来乍到的一个月，主要是从宏观上了解K8s，搭建各种K8s环境，包括但不限于pod创建流程、k8s核心四大件、pod常见问题及如何排查、创建pod到释放之间的流程\u0026hellip;.\n1月-today\n","permalink":"http://asakalan.github.io/posts/life/conlusion/","summary":"2022总结 今天是邻近2022年除夕的倒数第二天，回到家后好像也没什么事情干，索性写下了这边博客，算上为自己的2022年画上一个句号。 回顾起","title":"2022总结"},{"content":"Leetcode刷题记录 过滤器思想 1 2 3 4 5 6 for i,v:=range nums{ if (){ nums[cnt]=v cnt++ } } 核心思想 一个有序的数组 通过条件进行过滤后生成一个新的数组 前缀和思想 leetcode 1248 优美子数组\n核心思想 通过%2将找k个奇数的子数组=\u0026gt;找和为k的子数组=\u0026gt;s[i]-s[j]=k=\u0026gt;s[j] = s[i] - k nums: [1,1,2,1,1] nums%2: [1,1,0,1,1] sum: [0,1,2,2,3,4] count:[1,1,2,1,1] 1 2 3 4 5 6 7 8 res:=0 for _, s := range sum { if s-k \u0026gt;= 0 { res += count[s-k] } count[s]++ } return res ","permalink":"http://asakalan.github.io/posts/tech/4/","summary":"Leetcode刷题记录 过滤器思想 1 2 3 4 5 6 for i,v:=range nums{ if (){ nums[cnt]=v cnt++ } } 核心思想 一个有序的数组 通过条件进行过滤后生成一个新的数组 前缀和思想 leetcode 1248 优美子","title":"Leetcode刷题总结"},{"content":"Deepflow environment 配置 Agent Install Rust 1.curl https://sh.rustup.rs -sSf | sh\n2.source $HOME/.cargo/env\nInstall Golang 1.wget https://golang.google.cn/dl/go1.19.5.linux-amd64.tar.gz\n2.sudo tar -C /usr/local/ -xzf go1.19.5.linux-amd64.tar.gz\n3.cd /usr/local/\n4.echo $PATH\n5.sudo nano $HOME/.profile\n6.source .profile\nGolang set Proxy(不然后面下载ibGoReSym下不下来) /etc/profile export GOPROXY=https://goproxy.cn Install Protobuf-compiler(不然后面cargo b 涉及到proto的会报错) dnf install -y protobuf-compiler\nInstall clang llvm dnf install -y llvm11 gcc libpcap-devel glibc-static elfutils-libelf-devel make\ndnf install -y clang clang-devel llvm llvm-devel llvm-static ncurses-devel\ndnf install libpcap-devel libbpf-devel\nbcc environment preparation dnf install -y bison cmake ethtool flex git iperf libstdc++-static python-netaddr python-pip gcc gcc-c++ make zlib-devel elfutils-libelf-devel python-cachetools sudo dnf install -y luajit luajit-devel # for Lua support sudo dnf install -y http://repo.iovisor.org/yum/extra/mageia/cauldron/x86_64/netperf-2.7.0-1.mga6.x86_64.rpm sudo pip install pyroute2\nPull bcc git clone https://github.com/iovisor/bcc.git #直接拉取是最新版本 mkdir bcc/build; cd bcc/build cmake -DENABLE_LLVM_SHARED=1 ..\n这里会报错缺失一些文件: \u0026ndash; Could NOT find FFI (missing: FFI_LIBRARIES HAVE_FFI_CALL) \u0026ndash; Could NOT find LibDebuginfod (missing: LIBDEBUGINFOD_LIBRARIES LIBDEBUGINFOD_INCLUDE_DIRS) \u0026rsquo;netperf\u0026rsquo; not found \u0026lsquo;iperf\u0026rsquo; or \u0026lsquo;iperf3\u0026rsquo; not found 解决办法： sudo dnf install -y netperf sudo dnf install -y iperf sudo dnf install xz-devel\n编译 make sudo make install\nCompile agent-\u0026gt;cargo b(下面是各个错误的解决办法) 1. 致命错误：bcc/linux/bpf.h：没有那个文件或目录 解决办法： 去查询linux，和bcc的目录 whereis bcc # 会找到一个/usr/include/bcc的目录 whereis linux\n将linux这个目录拷贝到bcc下 cp -r /usr/include/linux/ /usr/include/bcc\n2. 致命错误：libdwarf-0/dwarf.h：没有那个文件或目录 解决办法：（以下步骤都可以加代理https://ghproxy.com/可以变的很快！） wget https://github.com/davea42/libdwarf-code/releases/download/v0.4.1/libdwarf-0.4.1.tar.xz tar -xf libdwarf-0.4.1.tar.xz cd libdwarf-0.4.1 CFLAGS=\u0026quot;-fpic\u0026quot; ./configure \u0026ndash;disable-dependency-tracking make \u0026amp;\u0026amp; make install \u0026amp;\u0026amp; make clean ln -s /usr/local/lib/libdwarf.a /usr/lib/libdwarf.a\n3. 致命错误：bpf/libbpf.h：没有那个文件或目录 sudo dnf install xz-devel sudo dnf install libbpf-devel\n4. 致命错误：libGoReSym.h：没有那个文件或目录 wget https://github.com/deepflowys/libGoReSym/archive/refs/tags/v0.0.1-2.tar.gz tar -xzf v0.0.1-2.tar.gz cd libGoReSym-0.0.1-2 make \u0026amp;\u0026amp; make install \u0026amp;\u0026amp; make clean\n5. 致命错误：缺少bddisasm git clone https://github.com/bitdefender/bddisasm cd bddisasm make \u0026amp;\u0026amp; make install \u0026amp;\u0026amp; make clean ln -s /usr/local/lib/libbddisasm.a /usr/lib/libbddisasm.a # 建立软链接, agent 静态库目录是 /usr/lib/ 和 /usr/lib64\n","permalink":"http://asakalan.github.io/posts/tech/3/","summary":"Deepflow environment 配置 Agent Install Rust 1.curl https://sh.rustup.rs -sSf | sh 2.source $HOME/.cargo/env Install Golang 1.wget https://golang.google.cn/dl/go1.19.5.linux-amd64.tar.gz 2.sudo tar -C /usr/local/ -xzf go1.19.5.linux-amd64.tar.gz 3.cd /usr/local/ 4.echo $PATH 5.sudo nano $HOME/.profile 6.source .profile Golang set Proxy(不然后面下载ibGoReSym下不下来) /etc/profile export GOPROXY=https://goproxy.cn Install Proto","title":"tech"},{"content":"子集 思路 循环条件:循环结束 可以使用递归的原因:选和不选的过程可以复用 核心代码 1 2 3 4 5 6 7 8 if i == len(nums){ ans = append(ans, append([]int(nil),chosen...)) return } chosen = append(chosen,nums[i]) recur(i+1,nums,chosen) chosen = chosen[:len(chosen)-1] recur(i+1,nums,chosen) ","permalink":"http://asakalan.github.io/posts/tech/huisu/","summary":"子集 思路 循环条件:循环结束 可以使用递归的原因:选和不选的过程可以复用 核心代码 1 2 3 4 5 6 7 8 if i == len(nums){ ans = append(ans, append([]int(nil),chosen...)) return } chosen = append(chosen,nums[i]) recur(i+1,nums,chosen) chosen = chosen[:len(chosen)-1] recur(i+1,nums,chosen)","title":"递归专题"},{"content":"环形链表 思路 设置快慢指针，快指针一次走两步，慢指针一次走一步，如果链表有环，则必定相遇，反之则不可以\n核心代码 1 2 3 4 5 6 7 8 9 fast:=head for (fast != nil \u0026amp;\u0026amp; fast.Next != nil){ head = head.Next fast = fast.Next.Next if (fast == head){ return true } } return false 链表的中间节点 思路 声明一个fast，slow指针，快指针走两步，慢指针走一步，当快指针走到空时，慢指针恰好走到在中间节点。\n核心代码 1 2 3 4 5 6 fast,slow:=head,head for (fast != nil \u0026amp;\u0026amp; fast.Next != nil){ fast = fast.Next.Next slow = slow.Next } return slow 删除链表的倒数第N个节点 思路 先声明一个保护节点，保护节点指向头节点，最后直接返回保护节点的下一个节点，即头节点。 1=\u0026gt;2=\u0026gt;3=\u0026gt;4=\u0026gt;5 如果要删除倒数第2个节点(4),其实我们只需要找到倒数第3个节点即(3)，即找到倒数第N+1个节点。 如果快指针走到尽头，慢指针刚好到倒数第n+1个节点，我们就可以运用快慢指针的思想。 关键问题 快慢指针补发是否需要保持一致？ 快指针需要领先慢指针多少步？ 慢指针走L-(n+1)步 快指针需要提前走L-[L-(n+1)]=n+1步 核心代码 1 2 3 4 5 6 7 8 9 10 11 p:=\u0026amp;Listnode{val:0 Next:head} fast,slow:=head,p for i:=0 ;i \u0026lt; n ;i++{ fast = fast.Next } for fast!=nil{ fast = fast.Next slow = slow.Next } slow = slow.Next.Next return p.Next 合并两个有序链表 思路 过滤器+双指针+保护节点\n一直遍历2个链表直到为空 当链表2为空或者链表1不为空且链表1的值小于链表2时 核心代码 1 2 3 4 5 6 7 8 9 10 11 12 13 head:=\u0026amp;ListNode{Val:0,Next:nil} p:=head for (list1!=nil || list2!=nil ){ if (list2 == nil || (list1!=nil \u0026amp;\u0026amp;list1.Val\u0026lt;list2.Val)){ head.Next = list1 list1 = list1.Next }else{ head.Next = list2 list2 = list2.Next } head = head.Next } return p.Next 反转链表 思路 1=\u0026gt;2=\u0026gt;3=\u0026gt;4=\u0026gt;5=\u0026gt;nil\nnil\u0026lt;=1 2\n让1与2的关系断裂之前，需要先将2的节点进行保存 next:=cur.Next 核心代码 1 2 3 4 5 6 7 8 var help *ListNode for cur!=nil{ next:=cur.Next cur.Next =help help = cur cur = cur.Next } return help K个一组反转链表 1=\u0026gt;2=\u0026gt;3=\u0026gt;4=\u0026gt;5\n思路 分组,往后遍历k-1步，为一组，head\u0026amp;end 组内做反转(反转链表的题解) 维护组间的边，前一个租、后一个组的边 核心代码 回文链表 思路 将链表中的值存放进数组中 进而用双指针进行判断 核心代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 arrays:=[]int{} for head!=nil{ arrays:=append(arrays,head.Val) head = head.Next } start,end:=0,len(arrays)-1 for start \u0026lt; end{ if vals[start]!=vals[end]{ return false } start++ end-- } return true ","permalink":"http://asakalan.github.io/posts/tech/5/","summary":"环形链表 思路 设置快慢指针，快指针一次走两步，慢指针一次走一步，如果链表有环，则必定相遇，反之则不可以 核心代码 1 2 3 4 5 6 7 8 9 fast:=head for (fast != nil \u0026amp;\u0026amp; fast.Next","title":"链表专题"},{"content":"Deepflow environment 配置 Server 1.Install Golang 1.1 wget https://golang.google.cn/dl/go1.19.5.linux-amd64.tar.gz\n1.2 sudo tar -C /usr/local/ -xzf go1.19.5.linux-amd64.tar.gz\n1.3 cd /usr/local/\n1.4 echo $PATH\n1.5 sudo nano $HOME/.profile\n1.6 source .profile\n2.Install Protobuf-compiler dnf install -y protobuf-compiler\n3.Set Proxy go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct\n4.Make Begin-\u0026gt;cd /server make 4.1 缺protoc-gen-gofast 解决办法-\u0026gt;go install github.com/gogo/protobuf/protoc-gen-gofast@latest\n4.2 ## 然后会出现 github.com/gogo/protobuf/gogoproto/gogo.proto: File not found.关闭代理(export GO111MODULE=\u0026ldquo;off\u0026rdquo;),然后执行\n4.3 go get github.com/gogo/protobuf(这一步因为网络问题,可能会出问题,多尝试几次即可)\n4.4 ## 紧接着会出现 protoc-gen-gogo: program not found or is not executable.\n4.5 执行go install github.com/gogo/protobufprotoc-gen-gogo@latest\n4.6 ## 然后会出现缺tmpl的错误,执行\n4.7 go install github.com/benbjohnson/tmpl@latest\n4.8 ## 接下来会出现缺少ujson包的问题，这一步需要使用python3 的pip3 install ujson，也是为什么建议使用Fedora，因为Centos系统太老,只有python2，python2-\u0026gt;pyhton3这一步如果使用centos会很麻烦！\n4.9 dnf install python3-pip\n4.10 pip3 install ujson\n总结:一路下来应该是没问题了,最终成功编译效果如下图(没有报错)\ntips:上述过程中涉及到的 protoc-gen-gogo、tmpl包经过go get后会自动生成在go/bin，但还需要将其分别添加到对应的 /usr/local/bin下才可以生效，以我个人环境为例如下图 ","permalink":"http://asakalan.github.io/posts/tech/2/","summary":"Deepflow environment 配置 Server 1.Install Golang 1.1 wget https://golang.google.cn/dl/go1.19.5.linux-amd64.tar.gz 1.2 sudo tar -C /usr/local/ -xzf go1.19.5.linux-amd64.tar.gz 1.3 cd /usr/local/ 1.4 echo $PATH 1.5 sudo nano $HOME/.profile 1.6 source .profile 2.Install Protobuf-compiler dnf install -y protobuf-compiler 3.Set Proxy go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 4.Make Begin-\u0026gt;cd /server make 4.1 缺protoc-gen-gofast 解","title":"实习总结"},{"content":"关于我\n英文名: Kevin Xu 职业: 程序员 运动: 跑步、乒乓球、爬山 ","permalink":"http://asakalan.github.io/aboud/","summary":"关于我 英文名: Kevin Xu 职业: 程序员 运动: 跑步、乒乓球、爬山","title":"🙋🏻‍♂️关于"}]